#' @rdname SOSet
#' @export
#'
setClass(
        "SOSet", # Spatial Omics Set
        representation = representation(
                NMFobjL = "list", # nmf objects/results, e.g., list(dataA = nmfObjResA, dataB = nmfObjResB)
                NMFrankL = "list", # select rank(s) to include in the correlation network, e.g., list(dataA = c(3:10, 15, 20), dataB = c(3:10, 15, 20))
                dataCol = "character", #  character vector of the corresponding colors to each dataset, e.g., c("dataA" = "red", "dataB" = "blue")
                basisMat = "matrix",
                corMat = "matrix", # Correlation matrix
                parameters = "list" # Stash parameters
        )
)
# TO-DOs: setValidity("SOSet", function(object) {}

#' @title SOSet object and contructor
#'
#' @description An S4 class to contain NMF results across ranks in multiple cohorts 
#'   and correlation matrix
#'
#' @details SOSet object contains NMF, or cNMF, results generated by
#'   the R NMF package, or the Python cNMF package, that deconvolutes
#'   expresion profiles of the tumors and/or multiple segments, i.e., regions of interest,
#'   from (spatial) transcriptomics, e.g., Nanostring Digital Spatial Profiler (DSP), in order to
#'   calculate correlation coefficients of the metagenes. The object also contains the 
#'   correlation matrix.
#'
#' @param NMFobjL A \code{list} containing \code{NMF}s type object for holding
#'      NMF results from NMF runs, where users run NMF on each dataset.
#' @param NMFrankL A \code{list} containing the ranks for each dataset that are
#'      considered to be included in SOSet, where we recommend to avoid to include
#'      low rank(s), i.e., rank = {2, 3, 4, ..., 20}
#' @param dataCol A \code{vector} of the colors that represent each dataset/NMF run.
#' @param basisMat A \code{matrix} that column-wide concatenate W (basis) matrices
#'      across data, where rows are genes and columns are metagenes
#'      (Gene Expression Programs).
#' @param corMet a character string indicating which correlation coefficient 
#'   (or covariance) is to be computed. One of "pearson", "kendall", 
#'   or "spearman" (default).
#' @param corUse an optional character string giving a method for computing covariances
#'   in the presence of missing values. This must be (an abbreviation of) one of 
#'   the strings "pairwise.complete.obs (default)", "everything", "all.obs", 
#'   "complete.obs", or "na.or.complete".
#'
#' @return SOSet object
#' 
#' @examples 
#' dataL <- list(DSP_WTA_DN = dsp_wta_dn_nmf_object, DSP_CTA_DN = ds_cta_dn_nmf_object)
#' rankL <- list(DSP_WTA_DN = c(3:10,15,18), DSP_CTA_DN = c(3:10,15,20,23))
#' col <- c("DSP_WTA_DN" = "cadetblue1", "DSP_CTA_DN" = "darkgoldenrod1")
#' corMet <- "pearson"
#' corUse <- "pairwise.complete.obs"
#' 
#' mxInput <- SOSet(NMFobjL = dataL, NMFrankL = rankL, dataCol = col, corMet = corMet, corUse = corUse)
#'
#' @docType class
#' @rdname SOSet
#' @import NMF corrr
#' @export
#'
SOSet <- function(NMFobjL, NMFrankL = NULL, dataCol = NULL, corMet = "spearman", corUse = "pairwise.complete.obs") {
        if (is.null(NMFobjL) || length(NMFobjL) == 0) {
                stop("ERROR::Provide at least one NMF object in list.")
        } else {
                message(paste0(length(NMFobjL), " dataset(s) found in the list: ", paste(names(NMFobjL), collapse = ", "), "\n"))
        }

        if (is.null(NMFrankL)) {
                message("WARNING::No NMFrankL provided - all ranks will be included.\n")
                NMFrankL <- sapply(NMFobjL, .getRank)
        } else {
                if (all(names(NMFobjL) %in% names(NMFrankL))) {
                        NMFrankL <- NMFrankL[which(names(NMFrankL) %in% names(NMFobjL))] 
                } else {
                        stop("ERROR::Check the names in NMFrankL whether they match with the names in NMFobjL.")
                }
        }

        if (!(corMet %in% c("pearson", "kendall", "spearman"))) {
                stop("ERROR::Provide either pearson, spearman, or kendall.")
        }

        if (!(corUse %in% c("everything", "all.obs", "complete.obs", "na.or.complete", "pairwise.complete.obs"))) {
                stop("ERROR::Please provide either pairwise.complete.obs, everything, all.obs, complete.obs, or na.or.complete.")
        }

        flags <- sapply(seq_along(NMFobjL), function(idx) {
                data <- NMFobjL[[idx]]
                dataName <- names(NMFobjL)[idx]
                flag <- FALSE
                if (class(data) != "NMF.rank") {
                        stop(paste0("ERROR::", dataName, " is not in NMF.rank class. You can use the importCNMF or mergeNMFruns function to create a NMF object."))
                } else {
                        flag <- TRUE
                }
                return(flag)
        })

        if (all(flags)) { # if all list items are in NMF.rank class
                basisMatL <- lapply(seq_along(NMFobjL), .getBasis, data = NMFobjL, rank = NMFrankL)

                if (any(length(Reduce(intersect, lapply(basisMatL, rownames))) < sapply(basisMatL, nrow))) {
                        message("WARNING::Number of genes are different across datasets.\n")
                        bMat <- as.data.frame(cbind(rownames(basisMatL[[1]]), basisMatL[[1]]))
                        colnames(bMat)[1] <- "Gene"
                        if (length(basisMatL) > 1) {
                                for (idx in c(2:length(basisMatL))) {
                                        tmpMat <- merge(bMat, basisMatL[[idx]], by.x = "Gene", by.y = "row.names", all = TRUE)
                                        bMat <- tmpMat
                                }
                        }
                        basisMat <- matrix(as.numeric(as.matrix(bMat[, c(2:ncol(bMat))])), ncol = ncol(bMat) - 1)
                        rownames(basisMat) <- bMat[, 1]
                        colnames(basisMat) <- colnames(bMat)[2:ncol(bMat)]
                } else {
                        message("Number of genes are the same across datasets.\n")
                        basisMat <- do.call(cbind, basisMatL)
                }

                corMat <- .getCor(basisMat, method = corMet, use = corUse)

                if (!is.null(dataCol)) {
                        if (!all(names(NMFobjL) %in% names(dataCol))) {
                                stop("ERROR::Please provide right names for the colours.")
                        } else {
                                message("\nAssigned color(s):")
                                dataCol <- sapply(seq_along(NMFobjL), function(idx) {
                                        cohort <- names(NMFobjL)[idx]
                                        dCol <- dataCol[cohort]
                                        names(dCol) <- cohort
                                        message(paste0(cohort), ": ", dataCol[cohort])
                                        return(dCol)
                                })
                                message("\n")
                        }
                } else {
                        message("WARNING::Rainbow colors will be assigned to the datasets.\n")
                        dataCol <- rainbow(length(NMFobjL))
                        names(dataCol) <- names(NMFobjL)
                }

                SOSet <- new(
                        "SOSet",
                        NMFobjL = NMFobjL,
                        NMFrankL = NMFrankL,
                        dataCol = dataCol,
                        basisMat = basisMat,
                        corMat = corMat,
                        parameters = list(corMet = corMet, corUse = corUse)
                )
        }

        return(SOSet)
}

.getRank <- function(obj) {
        return(as.numeric(names(obj$fit)))
}

.getBasis <- function(idx = NULL, data = NULL, rank = NULL) {
        dataName <- names(data)[idx]
        obj <- data[[idx]]
        rankRange <- rank[[idx]]
        message(paste0("Loading: ", dataName, " [Rank: ", toString(rankRange), "]"))

        basisMat <- c()
        for (k in rankRange) {
                basisRes <- NMF::basis(get(as.character(k), obj$fit))
                colnames(basisRes) <- paste0(
                        dataName, "$",
                        sprintf("%02d", c(1:ncol(basisRes))), "$", sprintf("%02d", k)
                )

                if (is.null(basisMat)) {
                        basisMat <- as.data.frame(cbind(rownames(basisRes), basisRes))
                        colnames(basisMat)[1] <- "GeneSymbol"
                } else {
                        tmp <- merge(x = basisMat, y = basisRes, by.x = "GeneSymbol", by.y = "row.names", all = T)
                        basisMat <- tmp
                }
        }
        rownames(basisMat) <- basisMat[, 1]
        basisMat <- basisMat[, c(2:ncol(basisMat))]

        allBasis <- matrix(as.numeric(unlist(basisMat)), ncol = ncol(basisMat), nrow = nrow(basisMat))
        rownames(allBasis) <- rownames(basisMat)
        colnames(allBasis) <- colnames(basisMat)

        return(allBasis)
}
# TO-DOs: a function that gets ranks when there are missing ranks for any cohorts

.getCor <- function(mat, method, use, diagonal = 0) {
    message("Calculating: all pairwise correlation coefficients.")
    correlation <- corrr::correlate(x = mat, method = method, use = use, diagonal = diagonal)

    corMat <- as.matrix(correlation[, c(2:ncol(correlation))])
    rownames(corMat) <- as.character(correlation$term)

    return(corMat)
}
# TO-DOs: parallelization, implement in C

#' Show a SOSet
#'
#' @param object \code{SOSet}
#'
#' @return Prints the SOSet object to the output stream, and returns invisible NULL.
#' @export
#'
setMethod(
        "show",
        signature = signature(object = "SOSet"),
        function(object) {
                cat("Dataset(s): \n")
                for(idx in seq_along(object@NMFobjL)) {
                        cat("\t", names(object@NMFobjL)[idx], " (", object@dataCol[idx], ")\n", sep="")
                }
                cat("Select rank(s): \n")
                for(idx in seq_along(object@NMFrankL)) {
                        cat("\t", names(object@NMFrankL)[idx], ": ", paste(object@NMFrankL[[idx]], collapse=", "), "\n", sep="")
                }
                cat("Basis (W) matrices: \n")
                cat("\t#Genes     : ", nrow(object@basisMat), "\n", sep="")
                cat("\t#Metagenes : ", ncol(object@basisMat), "\n", sep="")
                cat("Correlation method: \n") 
                cat("\t", object@parameters[["corMet"]], " (", object@parameters[["corUse"]], ")\n", sep="")                
                cat("Correlation matrix: \n")
                cat("\tSymmetric matrix with ", nrow(object@corMat), " columns X ", ncol(object@corMat), " rows.\n", sep="")
        }
)
